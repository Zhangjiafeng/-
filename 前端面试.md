## HTML



## CSS

#### rem

rem是相对于html元素的font-size的一个单位，如果html上定义了font-size：20px; 那么无论在任何地方1rem=20px；这个大小不受父元素影响。

#### div垂直居中

```css
div{
    position:absolute;
    top:50%;
    left:50%;
    height:100;
    width:100;
    margin-top:-50%;
    margin-left:-50%;
}

div{
    position:absolute;
    top:0;
    bottom:0;
    left:0;
    right:0;
    width:50%;
    height:50%;
    margin:auto;
}
```



## JavaScript

#### call与apply的区别是什么？哪一个性能更好一点？

两者的参数有区别，call会将参数逐个传入，而apply将参数以数组的形式传入

call的性能要比apply稍微好一些，尤其是参数大于三个的时候。

#### 实现(5).add(3).minus(2)

```js
~ function(){
    function check(num){
        num=Number(num);
        return isNaN(num)?0:num
    }
    function add(num){
        num=check(num)
        return this+num
    }
    function minus(num){
        num=check(num)
        return this-num
    }
    ['add','minus'].forEach(item=>{
        Number.prototype.item=eval(item)
    })
}();//立即运行 可以使用var x=function(){}()代替
(5).add(3).minus(2)
```

#### 箭头函数与普通函数的区别是什么？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？

箭头和普通函数的区别

1.箭头函数语法上比普通函数上更加简明(ES6中每一种函数都可以使用形参和剩余运算符)

```js
function fn(x){
    return function(y){
        return x+y
    }
}
let fn=x=>y=>x+y;
```

2.箭头函数没有自己的this，它里面出现的this是继承于函数所属上下文的this(使用call或者apply等任何方法也无法改变this的指向)。此外，回调函数中的this一般都是window。

回调函数：把一个函数B作为参数传递给另外一个函数A，函数A在执行的时候，可以把传递进来的函数B去执行（执行N次）

```js
function each(arr,callBack){
    for(let i=0;i<arr.length;i++){
        let flag=callBack.call(arr,arr[i],i)
        if(flag===false){
            break;
        }
    }
}
each([10,20,30,40],function(item,index){
    //=>this:原始操作数组
    if(index>1){
        return false
    }
})
```

3.箭头函数中没有arguments（类数组），只能基于...arg获取传递的参数集合（数组）

```js
let fn=(...arg)=>{
    //console.log(arguments) Uncaught ReferenceError:arguments is not defined
    console.log(arg)
}
fn(10,20,30);
```

4.箭头函数不能被new执行，箭头函数没有prototype也没有this，所以没法创建实例

#### 什么是函数节流？什么是函数防抖？

函数节流：一个函数执行一次后，只有大于设定的执行周期后才能执行第二次

有一个需要频繁触发函数，处于优化性能，在规定时间内，只让函数触发的第一次生效，后面不生效。

```js
function throttle(fn,delay){
    var lastTime=0;
    return function(){
        var nowTime=Date.now();
        if(nowTime-lastTime>delay){
            fn.call(this);
            lastTime=nowTime;
        }
    }
}
```

函数防抖：一个需要频繁触发的函数，在规定的时间内，只让最后一次生效，前面的不生效

```js
function debounce(fn,delay){
    var timer=null;
    return function(){
        clearTimeout(timer);
        timer=setTimeout(function(){
            fn.apply(this)
        },delay)
    }
}
```

#### 什么是跨域？解决跨域的办法有哪些？

1.同源策略：浏览器的安全策略，写一名、域名以及端口号必须完全一致

2.跨域：违背同源策略就会产生跨域

3.解决跨域：jsonp cors服务器代理

```js
var script=document.createELement('script');//创建script标签
function getData(data){
    console.log(data)//数据请求回来会触发的函数
}
script.src='http://localhost:3000?callback=getData';//设置script的src属性
document.body.appendChild(script);//让script生效
```

#### 什么是闭包？

1.密闭的容器，类似于set，map容器，存储数据的。

2.闭包是一个对象，存放数据的格式：key:value

3.闭包形成的条件：

函数嵌套，内部函数引用外部函数的局部变量

```js
function fun(){
    var count=1;
    return function(){
        count++;
        console.log(count)
    }
}
var f=fun();
f(); 
```

闭包的优点：延长了外部函数局部变量的生命周期，避免了全局变量的污染；

闭包的缺点：容易造成内存泄漏，常驻内存、增加内存的使用量；

注意点：合理的使用闭包，用完闭包要及时清除

#### 变量提升（预处理）

```js
console.log(username)//undefined
var username;
fun();//正常执行函数
function(){
    console.log('fun()');
}
```

js引擎在代码正式执行之前会做一个预处理工作；收集变量和函数

#### 执行上下文（execute context）

也就是代码执行的环境，代码在正式执行之前会进入到执行的环境；

工作流程：1.创建变量对象：1）变量 2）函数以及函数的参数

​					2.确认this的指向，全局：this->window    2）局部：this->调用的对象

​					3.创建作用域链，父级作用域链+当前的变量对象

函数加括号调用，则this指向window

```js
function fun1(fn){
    arguments[0](3,4);
}
function fun2(){
    alert(this.length)
}
fun1(fun2,5,6,7,8);//5
```

规则1：函数直接用圆括号运行，上下文是window对象。fn() 上下文是window

规则2：对象打点调用函数，上下文是这个对象。obj.fn() 上下文是这个obj

规则3：数组中枚举出函数，上下文是这个数组。

规则4：定时器调用函数，上下文是window。

规则5：被当做了事件处理函数，上下文是触发事件的DOM元素。

规则6：用new调用函数，上下文是函数体内秘密创建的空白对象。

用new创建函数会经过四步：1)秘密创建空对象  2）将this绑定到这个空对象中 3）执行语句  4）返回这个对象

规则7：用apply、call绑定执行上下文

```js
function Foo(){
    function getName(){
        alert(1)
    }
    return this;
}
Foo.prototype.getName(){
    alert(3)
}
function getName(){
    alert(2)
}
Foo().getName()//2
new Foo().getName()// 3
```

函数的length是形参的length，arguments的length是实参的length。

arguments.calee表示函数本身。

#### 基础点

只要协议、域名、端口有任何一个不同，就会被当作是不同的域

hasOwnProperty只能判断一个对象是否有指定名称的属性，不能判断出原型链上是否有；

监测一个js对象是否是Array,aa为要判断的对象，Object.prototype.toString.call(arr)

new Array(10).forEach(()=>{});forEach不会被执行，因为Array中元素为空时会跳过执行回调函数。

Promise有三个状态，pending、resolved、rejected。

typeof可以判断出string,number,boolean,undefined,symbol,object;

instanceof原理是构造函数的prototype属性是否出现在对象的圆形链中的任何位置；

JSON.parse(JSON.stringify())可以实现深拷贝

```js
//递归复制
function cloneObject(obj){
    var newObj={};
    if(typeof obj !== 'object'){
        return obj;
    }else{
        for(let attr in obj){
            newObj[attr] = cloneObject(obj[attr])
        }
    }
    return newObj;
}
```

数组去重的方法：

1.使用Set:let arr2=[...new Set(arr)];

2.使用forEach或者reduce进行遍历；

3.使用filter进行过滤，利用indexOf返回的位置与index进行对比；

#### 网页图片的懒加载

1.图片懒加载是前端性能优化的重要方法，通过图片或者数据的延时加载，我们可以加快页面渲染的速度，让第一次打开页面的速度边框；只有滑动到某个区域，我们才加载真实的图片，这样可以节省加载的流量。

2.处理方案：把所有需要延迟加载的图片用一个盒子包起来，设置宽高和默认占位图；开始让所有的src为空，把真实的图片地址放到img的自定义属性上，让img隐藏，等到其他所有资源加载完成后，我们再加载图片，对于很多图片，需要当页面滚动的时候，当前图片区域完全显示出来后再加载真实图片。

#### if语句求值使用eval函数

```js
let k=1;
if(functon f(){}){
    y+=typeof f;	
}
console.log(y); //1undefined
```

JavaScript中if求值语句使用eval函数，eval(function f(){})返回function(){}，也就是true。



delete操作符只能将对象中的属性删除，如何删除的不是对象的属性，那么delete操作符就不会生效。如过属性是通过原型链继承的也是无法delete的。

Boolean+Number->加法

Boolean+Boolean->加法

Number+String->连接

String+Boolean->连接

js为什么是单线程

这与js的用途有关，作为浏览器脚本语言，js主要用途就是与用户交互以及操作DOM，这决定它只能是单线程，如果是多线程，一个线程在DOM节点上添加内容，另一个线程删除这个节点，这是浏览器应该以哪个线程为准。为了利用多核CPU的计算能力，H5允许js创建多个线程，但是子线程受主线程控制，且不得操作DOM。所以，这个新准备并没有改变js单线程的本质。

#### 函数返回值问题

每个函数都有返回值，使用了return的话，则返回return后面跟的值，如果没有使用return，则默认返回undefined。特别的，如果这个函数是构造函数，则默认返回this对象，如果构造函数内使用了return语句，并且return后面跟的是一个对象，则这个构造函数的返回值是这个对象，否则返回的是this。

#### Promise

```js
class MyPromise{
    constructor(executor){
        this.state='pending';
        this.value=undefined;
        this.reason=undefined;
        let resolve=value=>{
            if(this.state==='pending'){
                this.state='fulfilled';
                this.value=value;
            }
        };
        let reject=reason=>{
            if(this.state==='pending'){
                this.state='rejected';
                this.reason=reason;
            }
        };
    }
    then(onFulfilled,onRejected){
        if(this.state==='fulfilled'){
            onFulfilled(this.value);
        }
        if(this.state==='rejected'){
            onRejected(this.reason);
        }
        if(this.state==='pending'){
            this.onResolvedCallbacks.push(()=>{
                onFulfilled(this.value);
            })
            this.onRejectedCallbacks.push(()=>{
                onRejected(this.value);
            })
        }
    }
    try{
        executor(resolve,reject);
    }catch(err){
        reject(err);
    }
}

```

#### Promise/async/await的执行顺序

```js
console.log('script start');

async function async1(){
    await async2();
    console.log('async1 end');
}

async function async2(){
    console.log('async2 end');
}

async1();

setTimeout(function(){
    console.log('Promise')
},0);

new Promise(resolve=>{
    console.log('Promise');
    resolve();
}).then(function(){
    console.log('promise1')
}).then(function(){
    console.log('promise2');
})

console.log('script end');

/**
 * sctipt start
 * async2 end
 * Promise
 * script end
 * async1 end
 * promise1
 * promise2
 * setTimeout
 */
```

遇到setTimeout，将输出放入下一轮宏任务队列；

遇到Promise对象，立即执行其函数，输出Promise，其后的resolve被放到了微任务队列；

宏任务执行完之后，执行微任务	

## NodeJS

#### Nodejs特点

1.单线程：单线程的好处就是减少了内存开销、操作系统的内存换页。如果一个事件进入了，但是被I/O阻塞了，则这个线程就阻塞了。

2.非阻塞I/O，不会等I/O语句结束，而会直接执行后面等待的语句。

3.事件驱动

事件机制：不管是新用户的请求，还是老用户的I/O，都将以事件的形式加入时间环，等待调度。

Nodejs中所有的I/O都是异步的，回调函数套回调函数。

#### nodejs的使用场景

nodejs处理异步I/O的能力比较强，处理计算以及逻辑的能力比较弱，所以可以把复杂的逻辑运算在前端处理，而nodejs只需要提供异步IO，这样就可以实现高性能处理。

擅长I/O，不善于计算，因为Nodejs最擅长的就是任务调度。

## React

#### React怎样控制异步和同步

在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中延时更新，而isBatchingUpdates默认是false，表示setState会同步更新this.state；但是，有一个batchedUpdates，该函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates将isBatchingUpdates修改为true，这样由React控制的事件处理过程setState不会同步更新this.state。

#### React中keys的作用是什么？

keys是react中用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，需要保证某个元素的key在同级元素中具有唯一性。在React Diff算法中react会借助元素的key来判断该元素是新近创建还是被移动而来的元素，从而减少不必要的元素重渲染。

#### 调用setState之后发生了什么？

调用setState之后，react会将传入的参数对象与组件当前的状态合并，然后触发调和过程。根据新的状态构建react元素树并着手重新渲染UI界面。得到新的元素树再与之前的树进行对比，根据差异进行最小化重渲染。

#### react生命周期函数

初始化阶段：

getDefaultProps:获取实例的默认属性

getInitialState:获取每个实例的初始化过程

componentWillMount:组件即将被装载、渲染到页面上

render:组件再这里生成虚拟的DOM节点

componentDidMount:组件真正被装载之后

运行中状态:

componentWillReceiveProps:组件将要接收到属性时候调用

shouldComponentUpdate:组件接收到新属性或者新状态的时候（可以返回false，接收数据后不再更新，阻止render的调用，后面的函数不会被继续执行了）

componentWillUpdate:组件即将更新不能修改属性和状态

render:组件重新描绘

componentDidUpdate:组件已经更新

销毁阶段：

componentWillUnmount:组件即将销毁

#### 为什么虚拟dom会提高性能？

虚拟dom相当于再js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。

用js对象结构表示dom树的结构；然后用这个树构建一个真正的DOM树，插到文档中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树与旧书进行对比，记录两者差异，然后对其中的差异进行更新。

#### render diff原理

把树形结构按照层级分解，只比较同级元素

把列表结构的每个单元添加唯一的key属性，方便比较。

react只会匹配相同class的component（这里面的class指的是组件的名字）

合并操作，调用component的setState方法的时候，react将其标记为dirty，到每一个事件循环结束，react检查所有标记为dirty的component重新绘制。

选择性字数渲染，开发人员可以重写。shouldComponentUpdate提高diff的性能。

## 简单算法

#### 数组的相关算法

##### 数组的去重

最简单的方法就是使用ES6的set

```js
let arr=[1,2,3,4,3,2,4,5,6,7];
console.log([...new Set(arr)])
```

遍历数组，若不在新建的数组中，就将元素push进去

```js
function uniq(arr){
    let res=[];
   	arr.forEach(item=>{
        if(res.indexOf(item)===-1){//也可以使用includes  res.includes(item)
            res.push(item)
        }
    })
    return res;
}  
```

##### 数组扁平化

```js
let arr=[0,[1,2,3],[4,[[[5,6]]]9,],10];
function flattenArray(arr){
    let _arr=[];
    arr.forEach(item=>{
        if(!Array.isArray(item)){
            _arr.push(item)
        }else{
            _arr=_arr.concat(flattenArray(arr[i]));
        }
    })
    return _arr;
}
```

#### 函数柯里化

 Ramda   Lodash(fp)库

#### 深浅拷贝

基本类型（number、string、boolean、undefined），传值的时候，内存会复制一份。

引用类型（function、object、array、regexp、null），传值的时候，内存不会复制。

```js
function deepClone(o){
    if(typeof o=="string"||typeof o=="number"||typeof o=="boolean"||typeof o=="undefined"){
        return o;
    }else if(Array.isArray(o)){
        let _arr=[];
        o.forEach(iem=>{
            _arr.deepClone(o[i])
        })
        return _arr;
    }else if(typeof o=="object"){
        let _o={};
        for(let k in o){
            _o[k]=deepClone(o[k])
        }
        return _o;
    }
}
```

## 网络

### HTTP

#### HTTP有什么特点

简单快速：客户向服务器请求服务时，只需传送请求方法和路径；

灵活：HTTP允许传输任意类型的数据对象。只在传输的类型由Content-Type加以标记；

无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接（深入-持久连接、管线化）

无状态：HTTP协议是无状态协议。

#### http与https协议有什么区别

http是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，是网络传输减少。

https是以安全为目标的HTTP通道，简单的讲就是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础就是SSL，因此加密的详细内容就需要SSL（Secure Sockets Layer 安全套接字）

http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议

http与https使用的是完全不同的连接方式，用的默认端口也不同，http是80，https是443

#### HTTP事务流程

1）域名解析

2）发起TCP的三次握手

3）建立TCP连接后发起HTTP请求

4）服务器响应http请求后，浏览器得到HTML代码

5）浏览器解析HTML，并请求HTML代码中的资源

6）浏览器对页面进行渲染并呈现给用户

7）连接结束

#### 用什么解析IP

从网址到IP的转换，成为DNS解析，DNS解析是一个递归查询的过程，以www.google.com为例：

1）在本地域名服务器中查询IP地址

2）如果没有找到，本地域名服务器会向根域名服务器发送一次请求

3）如果根域名服务器中不存在该域名，但判定这个域名属于".com"域，则向com顶级域名服务器发送一次请求；

4）如果com顶级服务器没有找到该域名，则判定这个域名属于google.com域，则本地域名服务器会向google.com域服务器发送一个请求，以此类推。

5）直到本地域名服务器得到域名对应域名的IP地址，并将其缓存到本地，以便下次使用

#### TCP三次握手？四次挥手？

三次握手的必要性：为了保证服务器能接收到客户端的信息并作出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行了后两次（第二次和第三次）握手

![img](https://img-blog.csdn.net/20180306090528688)

#### 常见的HTTP状态码

1**——信息，服务器收到请求，需要请求者继续完成操作

200——OK，请求成功

3**——重定向，需要进一步的操作以完成请求

401——请求要求用户的身份认证

403——禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致

404——Not Found，请求的资源不存在

500——内部服务器错误

502——充当网关或代理的服务器从远端服务器接收到一个无效的请求

504——充当网关或代理的服务器，未及时从远端服务器获取请求


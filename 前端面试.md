## HTML

#### 行内元素有哪些，块级元素有哪些，空（void）元素有哪些

- 行内元素：a span i img input select b等
- 块级元素：div ul ol lo h1~h6 p table等
- 空元素：br hr link等

#### 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解

- Trident内核：IE
- Gecko内核：NETSCAPE6及以上，火狐
- Presto内核：Opera7及以上
- Webkit内核：Safari，chrome

浏览器内核又可以分为两部分：渲染引擎和js引擎。渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，js引擎则是解析JavaScript语言，执行JavaScript语言来实现网页的动画效果。

#### html5有哪些新特性

- 语义化标签：header footer nav section article aside等
- 增强型表单：date(从一个日期选择器选择一个日期)、email(包含e-mail地址的输入域)、number(数值的输入域)、range(一定范围内数字值得输入域)、search(用于搜索域)、tel(定义输入电话号字段)等
- 视频和音频：audio、video
- Canvas绘图 SVG绘图
- 地理定位：Geolocation
- 拖放API：drag
- web worker：是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能。
- web storage：localStorage sessionStorage
- WebSocket：HTML5开始提供一种在单个TCP连接上进行全双工通讯的协议

#### 表单提交中的Get与Post的区别

1. Get一般用于服务器上获取数据，Post向服务器传送数据
2. Get传输的数据是拼接在Url之后的，对用户是可见的，Post的传输数据对用户是不可见的
3. Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制
4. Get安全性非常低，Post安全性较高
5. 在FORM提交的时候，如果不指定method，则默认为Get请求

#### 说一下HTML5 drag api

dragstart：事件主体是被拖放的元素，在开始拖放元素是触发。

drag：事件主体是被拖放元素，在正在拖放被拖放元素时触发。

dragenter：事件主体是目标元素，在拖放元素进入某元素时触发。

dragover：事件主体是目标元素，在被拖拽元素在目标元素中移动时触发。

dragleave：事件主体是目标元素，在被拖拽元素移出目标元素时触发。

drop：事件主体是目标元素，在目标元素完全接收被拖放元素时触发。

dropend：事件主体时被拖放元素，在整个拖放操作结束时触发。

#### docutype的作用？

docutype(document type:文档类型)：是一种标准通用标记语言的文档类型声明。作用：告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义来解析文档。

## CSS

#### css盒子模型，box-sizing属性的理解

css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定。

box-sizing(有三个值)：border-box,padding-box,content-box

标准盒子宽度=左右border+左右padding+width

IE盒子模型宽度：width

box-sizing：border-box表示IE盒子模型

![img](https://img2018.cnblogs.com/blog/1748092/201908/1748092-20190809145641572-714793117.jpg)

![img](https://img2018.cnblogs.com/blog/1748092/201908/1748092-20190809145529154-1986045519.jpg)

js获取盒模型对应的宽和高

- dom.style.width/height
- dom.currentStyle,width/height(只有IE支持)
- window.getComputedStyle(dom).width/height
- dom.getBoundingClientRect().width/height

#### px、em以及rem

- px：像素，相对长度单位，像素px是相对于显示器屏幕分辨率而言的
- em的值不是固定的，会继承父级元素的字体大小，代表倍数；
- rem是相对于html元素的font-size的一个单位，如果html上定义了font-size：20px; 那么无论在任何地方1rem=20px；这个大小不受父元素影响。


#### div垂直居中

```css
div{
    position:absolute;
    top:50%;
    left:50%;
    height:100;
    width:100;
    margin-top:-50%;
    margin-left:-50%;
}

div{
    position:absolute;
    top:0;
    bottom:0;
    left:0;
    right:0;
    width:50%;
    height:50%;
    margin:auto;
}
```

#### 清除浮动，什么时候需要清除浮动以及清除浮动的方法？

浮动的元素是脱离文档标准流的，如果不清除浮动，那么就会造成父元素高度塌陷，影响页面的布局。

清除浮动的方法：

- 为父元素设置高度；
- 为父元素增加overflow:hidden
- 为元素

```css
.fix::after{
    content:"";
    display:block;
    clear:both;
}
```

使用为元素的好处：不增加冗余的DOM节点，符合语义化

#### position的值有哪些？

- static：默认值，没有定位，元素出现在正常的流中；
- relative(相对定位)：生成相对定位的元素，相对于其正常位置进行定位
- absolute(绝对定位)：生成绝对定位的元素，相对与static定位以外的第一个父元素进行定位
- fixed(固定定位)：生成绝对定位的元素，相对与浏览器窗口进行定位

#### 什么响应式布局

响应式网站设计是一个网站能够兼容多个终端，而不会为了某一个终端做一个特定的版本。基本原理就是通过媒体查询检测不同的设备屏幕尺寸做处理。

#### css3的新特性

实现圆角border-radius,阴影box-shadow，边框图片box-image

对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient

实现旋转transform:rotate(90deg)，缩放scale(0.85,0.9)，translate(0px.-30px)定位，倾斜skew(-9deg,0deg);

增加了更多的css选择器、多背景、rgba()

唯一引入的为元素是::selection;

实现媒体查询@media，多栏布局flex

过渡transition,动画animation

#### ::before和:after中双冒号和但冒号有什么区别？

单冒号用于css3伪类，双冒号用于css3伪元素。

#### 如何画一个三角形

利用border

```css
div{
    width:0px;
    height:0px;
    border-top:10px solid red;
    border-left:10px solid transparent;
    border-right:10px solid transparent;
    border-bottom:10px solid transparent;
}
```

#### 画一条0.5px的线

采用meta viewport标签

```html
<meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
```

采用border-image的方式

采用transform:scale()的方式

#### link和import标签的区别

link使html的标签，而@import是css提供的

页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载

link时html的标签，因此没有兼容性，而@import只有IE5以上才能识别

link方式样式的权重高于@import的。

#### transition和animation的区别

animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from到to，而animation是一帧一帧的。

#### Flex布局

全程为flexible box（弹性布局）
flex-direction:row|row-reverse|column|column-reverse

flex-wrap:nowrap|wrap|wrap-reverse

flex-flow:<flex-direction>||<flex-wrap>

justify-content:对齐方式(水平)

align-items:对齐方式(竖直)

order:排序

flex-grow:定义项目的放大比例

flex-shrink:定义项目的缩小比例

#### BFC（块级格式化上下文，用于清除浮动，防止margin重叠等）

BFC区域不会域float box重叠

BFC是页面上的一个独立容器，子元素不会影响外面

计算BFC的高度时，浮动元素也会参加计算

哪些元素会产生BFC：

根元素 float不为none的元素 display为inline-block table-cell table-caption flex inline-flex

overflow不位visable的元素

position不为static；

#### 关于js动画和css3动画的差异性

渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个css动画得以在compositor thread完成（而js动画则会在main thread执行，然后compositor进行下一步操作），特别注意的是如果transform和opacity是不会layout和paint的。

功能涵盖面：js比css大

实现/重构难度不一：css3更加简单

对于帧速表现不好的浏览器，css3可以自然降级

css3有兼容性问题

#### css选择器有哪些，并说说优先级

id选择器，class选择器，标签选择器，伪元素选择器，伪类选择器、属性选择器

id>class>tag

带有!important的优先级最高；

样式表的优先级为：内联>内部样式>外部样式>浏览器用户自定义样式>浏览器默认样式

属性选择器的优先级和伪类选择器的优先级相同

#### 怎样让一个元素消失

display:none visibility:hidden opacity:0

#### CSS中哪些属性不能从父元素继承

例如margin、padding、border以及背景

#### 如何实现元素的垂直居中？

父元素display:flex;align-items:center;

元素绝对定位：top:50%;margin-top:-(高度/2)px;

高度不确定的情况使用transform:translateY(-50%)

父元素table布局，子元素设置vertical-align:center

#### calc属性

calc用于动态计算长度值，任何长度值都可以使用calc()函数计算，需要注意的是，运算符前后都要保留一个空格，例如：width:calc(100% - 10px)

#### 设置一个元素的背景颜色，背景颜色会填充哪些区域

background-color设置的背景颜色会填充元素的content padding 以及border

#### 重绘和重排，怎么减少重绘和重排，让文档脱离文档流的方法？

DOM变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会收到影响，浏览器需要重新构造渲染树，这个过程叫重排，浏览器将收到影响的部分重新绘制在屏幕上成为重绘。

添加删除可见的DOM元素，元素的尺寸位置发生变化，浏览器页面的初始胡，浏览器窗口大小发生变化，重排一定会导致重绘，重绘不一定会重排。

对于多次重拍的元素，比如说动画，可以使用绝对定位，让其脱离文档流，使其不影响其他元素。

#### block inline以及inline-block的区别

block元素会独占一行，多个block元素会各自新起一行，默认情况下，block元素宽度会自动填充父元素的宽度。block元素可以设置width height，块级元素即使设置了宽度，依旧占一行。可以设置margin和padding属性。

inline元素不会独占一行，多个相邻的行内元素会排列在同一行，直到一行排列不下，其宽度会随元素的内容变化而变化。inline元素设置width以及height无效，inline元素的margin以及padding只在水平方向上起作用，竖直方向不会产生效果。

inline-block:简单的说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会排列在同一行。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性有具有inline的同行特性。

此外，img、input等内联元素可以设置宽和高，因为对于元素本身来讲，可以分为替换元素和非替换元素，所谓替换元素就是浏览器根据元素的标签和属性，来决定元素具体显示内容。浏览器会根据img标签的src属性的值来读取图片的信息并显示出来。

#### 页面布局实现左中右（左右300px，中间自适应）

- 浮动布局

  ```css
  .outDiv{
      width:100%;
      height:100px;
  }
  .left{
      width:300px;
      height:100px;
      float:left;
      background:red;
  }
  .right{
      width:300px;
      height:100px;
      float:right;
      background:blue
  }
  .center{
      background:yellow;
      height:100px;
  }
  ```

  

- flex布局解决

  ```css
  .outDiv{
      display:flex;
      width:100%;
  }
  .left{
      width:300px;
      background:red;
  }
  .center{
      flex:1;
      background:yellow;
  }
  .right{
      width:300px;
      background:blue;
  }
  ```

  

- 绝对定位

  ```css
  .outDiv{
      width:100%;
      height:100px;
      position:relative;
  }
  .left{
      position:absolute;
      left:0;
      background:red;
      height:100px;
      width:300px;
  }
  .center{
      position:absolute;
      left:300px;
      right:300px;
      background:yellow;
      height:100px;
  }
  .right{
      height:100px;
      position:absolute;
      right:0;
      width:300px;
      background:blue;
  }
  ```

  

- table

  ```css
  .outDiv{
      width:100%;
      height:100px;
      display:table;
  }
  .left{
      height：100px;
      display:table-cell;
      width:300px;
      background:red;
  }
  .center{
      display:table-cell;
      height:100px;
      background:yellow;
  }
  .right{
      display:table-cell;
      height:100px;
      background:blue;
      width:300px;
  }
  ```

  

- 网格布局

  ```css
  .outDiv{
      display:grid;
      width:100%;
      grid-template-rows:100px;
      grid-template-columns:300px auto 300px;
  }
  ```



## JavaScript

#### call与apply的区别是什么？哪一个性能更好一点？

两者的参数有区别，call会将参数逐个传入，而apply将参数以数组的形式传入

call的性能要比apply稍微好一些，尤其是参数大于三个的时候。



#### 实现(5).add(3).minus(2)

```js
~ function(){
    function check(num){
        num=Number(num);
        return isNaN(num)?0:num
    }
    function add(num){
        num=check(num)
        return this+num
    }
    function minus(num){
        num=check(num)
        return this-num
    }
    ['add','minus'].forEach(item=>{
        Number.prototype.item=eval(item)
    })
}();//立即运行 可以使用var x=function(){}()代替
(5).add(3).minus(2)
```

#### 箭头函数与普通函数的区别是什么？构造函数可以使用new生成实例，那么箭头函数可以吗？为什么？

箭头和普通函数的区别

1.箭头函数语法上比普通函数上更加简明(ES6中每一种函数都可以使用形参和剩余运算符)

```js
function fn(x){
    return function(y){
        return x+y
    }
}
let fn=x=>y=>x+y;
```

2.箭头函数没有自己的this，它里面出现的this是继承于函数所属上下文的this(使用call或者apply等任何方法也无法改变this的指向)。此外，回调函数中的this一般都是window。

回调函数：把一个函数B作为参数传递给另外一个函数A，函数A在执行的时候，可以把传递进来的函数B去执行（执行N次）

```js
function each(arr,callBack){
    for(let i=0;i<arr.length;i++){
        let flag=callBack.call(arr,arr[i],i)
        if(flag===false){
            break;
        }
    }
}
each([10,20,30,40],function(item,index){
    //=>this:原始操作数组
    if(index>1){
        return false
    }
})
```

3.箭头函数中没有arguments（类数组），只能基于...arg获取传递的参数集合（数组）

```js
let fn=(...arg)=>{
    //console.log(arguments) Uncaught ReferenceError:arguments is not defined
    console.log(arg)
}
fn(10,20,30);
```

4.箭头函数不能被new执行，箭头函数没有prototype也没有this，所以没法创建实例

#### 什么是函数节流？什么是函数防抖？

函数节流：一个函数执行一次后，只有大于设定的执行周期后才能执行第二次

有一个需要频繁触发函数，处于优化性能，在规定时间内，只让函数触发的第一次生效，后面不生效。

```js
function throttle(fn,delay){
    var lastTime=0;
    return function(){
        var nowTime=Date.now();
        if(nowTime-lastTime>delay){
            fn.call(this);
            lastTime=nowTime;
        }
    }
}
```

函数防抖：一个需要频繁触发的函数，在规定的时间内，只让最后一次生效，前面的不生效

```js
function debounce(fn,delay){
    var timer=null;
    return function(){
        clearTimeout(timer);
        timer=setTimeout(function(){
            fn.apply(this)
        },delay)
    }
}
```

#### 什么是跨域？解决跨域的办法有哪些？

1.同源策略：浏览器的安全策略，限制从一个源加载的文档和另一个源的资源进行交互，协议名、域名以及端口号必须完全一致 

2.跨域：违背同源策略就会产生跨域

3.解决跨域：jsonp cors服务器代理

```js
var script=document.createELement('script');//创建script标签
function getData(data){
    console.log(data)//数据请求回来会触发的函数
}
script.src='http://localhost:3000?callback=getData';//设置script的src属性
document.body.appendChild(script);//让script生效
```

Hash //场景是当前页面A 通用iframe或者frame嵌入了跨域页面B

```js
let B=document.getElementsByTagName('iframe');
B.src=B.src+'#'+'data';
window.onhashchange=function(){
    let data=window.location.hash
}
```

postMessage //场景与Hash一样

```js
Bwindow.postMessage('data','http://B.com')
window.addEventListener('message',function(event){
    console.log(event.origin,event.source,event.data)
},false)
```

webSocket

```js
let ws=new WebSocket('wss://echo.websocket.org');
ws.onopen=function(evt){
    console.log('Connect open...')
    ws.send('Hello, WebSocket!')
}
ws.onMessage=function(evt){
    console.log('Received Message'+evt.data);
    ws.close();
}
ws.onclose=function(evt){
    console.log('Connection closed')
}

```



#### 前后端如何通信

- ajax

ajax的创建：

```js
let xhr=XMLHttpRequest?new XMLHttpRequest():new window.ActiveObject('Microsoft.XMLHTTP');

```



- websocket
- CORS

#### 什么是闭包？

1. 密闭的容器，类似于set，map容器，存储数据的。

2. 闭包是一个对象，存放数据的格式：key:value
3. 闭包形成的条件：

函数嵌套，内部函数引用外部函数的局部变量

```js
function fun(){
    var count=1;
    return function(){
        count++;
        console.log(count)
    }
}
var f=fun();
f(); 
```

闭包的优点：延长了外部函数局部变量的生命周期，避免了全局变量的污染；

闭包的缺点：容易造成内存泄漏，常驻内存、增加内存的使用量；

注意点：合理的使用闭包，用完闭包要及时清除

闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。

#### 创建对象的方法

```js
let o1={name:'o1'}
let o11=new Object({name:'o11'})

let M=function(){this.name="o2"}
let o2=new M();

let P={name:'o3'};
let o3=Object.create(P);
```

#### 原型链

![img](https://upload-images.jianshu.io/upload_images/1490251-3089c135df71c956.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

#### 变量提升（预处理）

```js
console.log(username)//undefined
var username;
fun();//正常执行函数
function(){
    console.log('fun()');
}
```

js引擎在代码正式执行之前会做一个预处理工作；收集变量和函数

#### 执行上下文（execute context）

也就是代码执行的环境，代码在正式执行之前会进入到执行的环境；

工作流程：1.创建变量对象：1）变量 2）函数以及函数的参数

​					2.确认this的指向，全局：this->window    2）局部：this->调用的对象

​					3.创建作用域链，父级作用域链+当前的变量对象

函数加括号调用，则this指向window

```js
function fun1(fn){
    arguments[0](3,4);
}
function fun2(){
    alert(this.length)
}
fun1(fun2,5,6,7,8);//5
```

规则1：函数直接用圆括号运行，上下文是window对象。fn() 上下文是window

规则2：对象打点调用函数，上下文是这个对象。obj.fn() 上下文是这个obj

规则3：数组中枚举出函数，上下文是这个数组。

规则4：定时器调用函数，上下文是window。

规则5：被当做了事件处理函数，上下文是触发事件的DOM元素。

规则6：用new调用函数，上下文是函数体内秘密创建的空白对象。

用new创建函数会经过四步：1)秘密创建空对象  2）将this绑定到这个空对象中 3）执行语句  4）返回这个对象

规则7：用apply、call绑定执行上下文

```js
function Foo(){
    function getName(){
        alert(1)
    }
    return this;
}
Foo.prototype.getName(){
    alert(3)
}
function getName(){
    alert(2)
}
Foo().getName()//2
new Foo().getName()// 3
```

函数的length是形参的length，arguments的length是实参的length。

arguments.calee表示函数本身。

#### 基础点

只要协议、域名、端口有任何一个不同，就会被当作是不同的域

hasOwnProperty只能判断一个对象是否有指定名称的属性，不能判断出原型链上是否有；

监测一个js对象是否是Array,aa为要判断的对象，Object.prototype.toString.call(arr)

new Array(10).forEach(()=>{});forEach不会被执行，因为Array中元素为空时会跳过执行回调函数。

Promise有三个状态，pending、resolved、rejected。

typeof可以判断出string,number,boolean,undefined,symbol,object;

instanceof原理是构造函数的prototype属性是否出现在对象的圆形链中的任何位置；

JSON.parse(JSON.stringify())可以实现深拷贝

```js
//递归复制
function cloneObject(obj){
    var newObj={};
    if(typeof obj !== 'object'){
        return obj;
    }else{
        for(let attr in obj){
            newObj[attr] = cloneObject(obj[attr])
        }
    }
    return newObj;
}
```

数组去重的方法：

1.使用Set:let arr2=[...new Set(arr)];

2.使用forEach或者reduce进行遍历；

3.使用filter进行过滤，利用indexOf返回的位置与index进行对比；

#### DOM事件

##### DOM事件类：

DOM0 element.onclick=function(){}

DOM2 element.addEventListener('click',function(){},false)//true表示捕获过程触发，false表示冒泡过程触发。

DOM3 element.addEventListener('keyup',function(){},false)

##### 事件模型

捕获：从上往下

冒泡：从下往上

##### 事件流

事件通过捕获到达目标，目标向上冒泡

##### 描述DOM事件捕获的具体流程

window->document->html->body->...->目标元素

##### event对象常见应用

event.preventDefault();//阻止默认行为

event.stopPropagation();//阻止冒泡行为

event.stopImmediatePropagation();

event.currentTarget;

event.target;

##### 自定义事件

```js
let eve=new Element('custome');
el.addEventListener('custome',function(){
    console.log('custome')
})
el.dispatchEvent(eve);
```



#### 网页图片的懒加载

1.图片懒加载是前端性能优化的重要方法，通过图片或者数据的延时加载，我们可以加快页面渲染的速度，让第一次打开页面的速度边框；只有滑动到某个区域，我们才加载真实的图片，这样可以节省加载的流量。

2.处理方案：把所有需要延迟加载的图片用一个盒子包起来，设置宽高和默认占位图；开始让所有的src为空，把真实的图片地址放到img的自定义属性上，让img隐藏，等到其他所有资源加载完成后，我们再加载图片，对于很多图片，需要当页面滚动的时候，当前图片区域完全显示出来后再加载真实图片。

#### if语句求值使用eval函数

```js
let k=1;
if(functon f(){}){
    y+=typeof f;	
}
console.log(y); //1undefined
```

JavaScript中if求值语句使用eval函数，eval(function f(){})返回function(){}，也就是true。



delete操作符只能将对象中的属性删除，如何删除的不是对象的属性，那么delete操作符就不会生效。如过属性是通过原型链继承的也是无法delete的。

Boolean+Number->加法

Boolean+Boolean->加法

Number+String->连接

String+Boolean->连接

js为什么是单线程

这与js的用途有关，作为浏览器脚本语言，js主要用途就是与用户交互以及操作DOM，这决定它只能是单线程，如果是多线程，一个线程在DOM节点上添加内容，另一个线程删除这个节点，这是浏览器应该以哪个线程为准。为了利用多核CPU的计算能力，H5允许js创建多个线程，但是子线程受主线程控制，且不得操作DOM。所以，这个新准备并没有改变js单线程的本质。

#### 函数返回值问题

每个函数都有返回值，使用了return的话，则返回return后面跟的值，如果没有使用return，则默认返回undefined。特别的，如果这个函数是构造函数，则默认返回this对象，如果构造函数内使用了return语句，并且return后面跟的是一个对象，则这个构造函数的返回值是这个对象，否则返回的是this。

#### Promise

```js
class MyPromise{
    constructor(executor){
        this.state='pending';
        this.value=undefined;
        this.reason=undefined;
        let resolve=value=>{
            if(this.state==='pending'){
                this.state='fulfilled';
                this.value=value;
            }
        };
        let reject=reason=>{
            if(this.state==='pending'){
                this.state='rejected';
                this.reason=reason;
            }
        };
    }
    then(onFulfilled,onRejected){
        if(this.state==='fulfilled'){
            onFulfilled(this.value);
        }
        if(this.state==='rejected'){
            onRejected(this.reason);
        }
        if(this.state==='pending'){
            this.onResolvedCallbacks.push(()=>{
                onFulfilled(this.value);
            })
            this.onRejectedCallbacks.push(()=>{
                onRejected(this.value);
            })
        }
    }
    try{
        executor(resolve,reject);
    }catch(err){
        reject(err);
    }
}

```

#### Promise/async/await的执行顺序

```js
console.log('script start');

async function async1(){
    await async2();
    console.log('async1 end');
}

async function async2(){
    console.log('async2 end');
}

async1();

setTimeout(function(){
    console.log('Promise')
},0);

new Promise(resolve=>{
    console.log('Promise');
    resolve();
}).then(function(){
    console.log('promise1')
}).then(function(){
    console.log('promise2');
})

console.log('script end');

/**
 * sctipt start
 * async2 end
 * Promise
 * script end
 * async1 end
 * promise1
 * promise2
 * setTimeout
 */
```

遇到setTimeout，将输出放入下一轮宏任务队列；

遇到Promise对象，立即执行其函数，输出Promise，其后的resolve被放到了微任务队列；

宏任务执行完之后，执行微任务	

#### 几个很实用的BOM属性对象方法

BOM是浏览器对象

location对象

- location.href——返回或设置当前文档的url
- location.search——返回url中的查询字符串部分（返回?后面的内容）
- location.hash——返回url#后面的内容，没有#则返回空
- location.host——返回www.dreamdu.com
- 此外还有hostname pathname port protocol assign 等

history对象

- history.go()——前进或后退指定的页面数 history.go(num)
- history.back()——后退一页
- history.forward()——前进一页

Navigator对象

navigator.userAgent——返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)

navigator.cookieEnabled——返回浏览器是否支持cookie

#### 面向对象的继承方法

```js
/*借助构造函数实现继承，这是一种不完全继承，不能继承Parent的prototype中的属性*/
function Parent(){
    this.name='parent'
}
function Child(){
    Parent.call(this);
    this.type='child'
};

/*借助原型链实现继承*/
function Parent(){
    this.name="parent"
}
function Child(){
    this.type='child'
}
Child.prototype=new Parent();

/*组合继承*/
function Parent(){
    this.name='parent';
    this.play=[1,2,3];
}
function Child(){
    Parent.call(this);
    this.type='child';
}
Child.prototype=Object.create(Parent.prototype);
Child.prototype.constructor=Child;
```



## NodeJS

#### Nodejs特点

1.单线程：单线程的好处就是减少了内存开销、操作系统的内存换页。如果一个事件进入了，但是被I/O阻塞了，则这个线程就阻塞了。

2.非阻塞I/O，不会等I/O语句结束，而会直接执行后面等待的语句。

3.事件驱动

事件机制：不管是新用户的请求，还是老用户的I/O，都将以事件的形式加入时间环，等待调度。

Nodejs中所有的I/O都是异步的，回调函数套回调函数。

#### nodejs的使用场景

nodejs处理异步I/O的能力比较强，处理计算以及逻辑的能力比较弱，所以可以把复杂的逻辑运算在前端处理，而nodejs只需要提供异步IO，这样就可以实现高性能处理。

擅长I/O，不善于计算，因为Nodejs最擅长的就是任务调度。

#### Nodejs的缺点

- nodejs更新很快，可能出现版本兼容问题
- nodejs还不成熟
- nodejs对于不同的链接，不支持进程和线程操作

#### 什么是错误优先的回调函数？

错误优先的回调函数用于同时返回错误和数据，第一个参数是错误，并且验证它是否出错，如：

```js
fs.readFile(filePath,function(err,data){
    if(err){
        console.log(err);
    }else{
        cnsole.log(data);
    }
})
```

#### 如何避免回调地狱？

模块化：将回调函数转换为独立的函数

使用流程控制库

使用promise

使用async/await

#### 保证代码风格的工具

团队协作时，保证一致的代码风格是非常重要的，这样团队成员才能更快的修改代码，而不需要去适应新的风格：

ESLint  Starndard JSLint JSCS

#### Express和koa的区别？

Express主要基于Connect中间件框架，功能丰富，随取随用，并且框架自身封装了大量便利的功能，比如路由视图处理等等，而Koa主要基于co中间件框架，框架自身并没有集成太多功能，大部分功能需要用户自行require中间件去解决，但是由于其基于ES6 generator特性的中间件机制，解决了callback hell

#### Redis

使用场景：支持String list set zset以及hash类型数据

配合关系型数据库做高速缓存

缓存高频次访问的数据，降低数据库io

分布式架构，做session共享

可以持久化特定数据

#### mysql和mongodb的区别

mysql时关系型数据库而mongodb时非关系型数据库

#### Nodejs事件轮询

![img](https://images2015.cnblogs.com/blog/104032/201509/104032-20150917141055570-1948801510.png)

事件轮询是nodejs虽然是单线程，但是可以进行处理高并发，高吞吐量的核心，一个事件轮询拥有以下三个部分：

事件队列：这是一个FIFO模型的队列，一方面推入事件，另一方面推出事件

队列的读取轮询线程组件，也就是主教Event Loop

单独的线程池：用来执行长任务

## React

#### React怎样控制异步和同步

在React的setState函数实现中，会根据一个变量isBatchingUpdates判断是直接更新this.state还是放到队列中延时更新，而isBatchingUpdates默认是false，表示setState会同步更新this.state；但是，有一个batchedUpdates，该函数会把isBatchingUpdates修改为true，而当React在调用事件处理函数之前就会调用这个batchedUpdates将isBatchingUpdates修改为true，这样由React控制的事件处理过程setState不会同步更新this.state。

#### React中keys的作用是什么？

keys是react中用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。

在开发过程中，需要保证某个元素的key在同级元素中具有唯一性。在React Diff算法中react会借助元素的key来判断该元素是新近创建还是被移动而来的元素，从而减少不必要的元素重渲染。

#### 调用setState之后发生了什么？

调用setState之后，react会将传入的参数对象与组件当前的状态合并，然后触发调和过程。根据新的状态构建react元素树并着手重新渲染UI界面。得到新的元素树再与之前的树进行对比，根据差异进行最小化重渲染。

#### react生命周期函数

初始化阶段：

getDefaultProps:获取实例的默认属性

getInitialState:获取每个实例的初始化过程

componentWillMount:组件即将被装载、渲染到页面上

render:组件再这里生成虚拟的DOM节点

componentDidMount:组件真正被装载之后

运行中状态:

componentWillReceiveProps:组件将要接收到属性时候调用

shouldComponentUpdate:组件接收到新属性或者新状态的时候（可以返回false，接收数据后不再更新，阻止render的调用，后面的函数不会被继续执行了）

componentWillUpdate:组件即将更新不能修改属性和状态

render:组件重新描绘

componentDidUpdate:组件已经更新

销毁阶段：

componentWillUnmount:组件即将销毁

#### 为什么虚拟dom会提高性能？

虚拟dom相当于再js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。

用js对象结构表示dom树的结构；然后用这个树构建一个真正的DOM树，插到文档中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树与旧书进行对比，记录两者差异，然后对其中的差异进行更新。

#### render diff原理

把树形结构按照层级分解，只比较同级元素

把列表结构的每个单元添加唯一的key属性，方便比较。

react只会匹配相同class的component（这里面的class指的是组件的名字）

合并操作，调用component的setState方法的时候，react将其标记为dirty，到每一个事件循环结束，react检查所有标记为dirty的component重新绘制。

选择性字数渲染，开发人员可以重写。shouldComponentUpdate提高diff的性能。

#### shouldComponentUpdate是做什么的（React性能优化是哪个周期函数）？

shouldComponentUpdate这个方法用来判断是否需要调用render方法重新描绘dom，因为dom的描绘是非常消耗性能的，如果我们能在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能。

#### React中refs的作用是什么？

refs是react提供给我们安全访问DOM元素或者某个组件实例的句柄，我们可以为元素添加ref属性，然后在回调函数中接收该元素在dom树中的句柄，该值作为回调函数的第一个参数返回：

```js
class CustomForm extends Component{
    handleSubmit=()=>{
        console.log("input value",this.input.value)
    }
    render(){
        return (
       		<View>
            	<Input type='text' ref={(input)=>this.input=input}/>
            </View> 
        )
    }
}
```

上述代码中的input中包含了ref属性，该属性声明的回调函数会接收input对应的DOM元素，我们将其绑定到this指针以便在其他的类函数中使用。另外值得一提的是，refs并不是类组件的专属，函数实组件同样可以利用闭包暂存其值。

#### 

## 简单算法

#### 数组的相关算法

##### 数组的去重

最简单的方法就是使用ES6的set

```js
let arr=[1,2,3,4,3,2,4,5,6,7];
console.log([...new Set(arr)])
```

遍历数组，若不在新建的数组中，就将元素push进去

```js
function uniq(arr){
    let res=[];
   	arr.forEach(item=>{
        if(res.indexOf(item)===-1){//也可以使用includes  res.includes(item)
            res.push(item)
        }
    })
    return res;
}  
```

##### 数组扁平化

```js
let arr=[0,[1,2,3],[4,[[[5,6]]]9,],10];
function flattenArray(arr){
    let _arr=[];
    arr.forEach(item=>{
        if(!Array.isArray(item)){
            _arr.push(item)
        }else{
            _arr=_arr.concat(flattenArray(arr[i]));
        }
    })
    return _arr;
}

arr.flat(Infinity);

Array.from(new Set(arr.toString().split(',').map(item=>Number(item))))

JSON.stringify(arr).replace(/(\[|\])/g,'').split(',').map(item=>Number(item))
```

#### 函数柯里化

 Ramda   Lodash(fp)库

#### 深浅拷贝

基本类型（number、string、boolean、undefined），传值的时候，内存会复制一份。

引用类型（function、object、array、regexp、null），传值的时候，内存不会复制。

```js
function deepClone(o){
    if(typeof o=="string"||typeof o=="number"||typeof o=="boolean"||typeof o=="undefined"){
        return o;
    }else if(Array.isArray(o)){
        let _arr=[];
        o.forEach(iem=>{
            _arr.deepClone(o[i])
        })
        return _arr;
    }else if(typeof o=="object"){
        let _o={};
        for(let k in o){
            _o[k]=deepClone(o[k])
        }
        return _o;
    }
}
```

#### 

## 网络

### HTTP

#### HTTP有什么特点

简单快速：客户向服务器请求服务时，只需传送请求方法和路径；

灵活：HTTP允许传输任意类型的数据对象。只在传输的类型由Content-Type加以标记；

无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接（深入-持久连接、管线化）

无状态：HTTP协议是无状态协议。

#### HTTP报文的组成部分

请求报文：请求行(http方法，页面地址，http协议以及版本） 请求头(告诉服务端需要的内容个类型) 空行(告诉服务端以下是请求体) 请求体

响应报文：状态行 响应头 空行 响应体

#### HTTP方法

GET POST PUT(更新资源) DELETE HEAD(获得报文头部)

#### GET和POST的区别

GET在浏览器回退时是无害的，而POST会再次提交请求

GET产生的URL地址可以被收藏，而POST不可以

GET请求会被浏览器主动缓存，而POST不会，除非手动设置

GET请求只能进行url编码，而POST支持多种编码方式

GET请求参数会被完整保留在浏览器历史记录中，而POST的参数不会被保留

GET请求在url中传送的参数是有长度限制的，而POST没有限制

对参数的数据类型，GET只接受ASCII字符，而POST没有限制

POST更安全，GET的参数直接暴露在URL上

GET的参数通过url传递，POST放在Request body中

#### http与https协议有什么区别

http是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，是网络传输减少。

https是以安全为目标的HTTP通道，简单的讲就是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础就是SSL，因此加密的详细内容就需要SSL（Secure Sockets Layer 安全套接字）

http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议

http与https使用的是完全不同的连接方式，用的默认端口也不同，http是80，https是443

#### HTTP事务流程

1）域名解析

2）发起TCP的三次握手

3）建立TCP连接后发起HTTP请求

4）服务器响应http请求后，浏览器得到HTML代码

5）浏览器解析HTML，并请求HTML代码中的资源

6）浏览器对页面进行渲染并呈现给用户

7）连接结束

#### 用什么解析IP

从网址到IP的转换，成为DNS解析，DNS解析是一个递归查询的过程，以www.google.com为例：

1）在本地域名服务器中查询IP地址

2）如果没有找到，本地域名服务器会向根域名服务器发送一次请求

3）如果根域名服务器中不存在该域名，但判定这个域名属于".com"域，则向com顶级域名服务器发送一次请求；

4）如果com顶级服务器没有找到该域名，则判定这个域名属于google.com域，则本地域名服务器会向google.com域服务器发送一个请求，以此类推。

5）直到本地域名服务器得到域名对应域名的IP地址，并将其缓存到本地，以便下次使用

#### TCP三次握手？四次挥手？

三次握手的必要性：为了保证服务器能接收到客户端的信息并作出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行了后两次（第二次和第三次）握手

![img](https://img-blog.csdn.net/20180306090528688)

#### 常见的HTTP状态码

1**——信息，服务器收到请求，需要请求者继续完成操作

200——OK，请求成功

3**——重定向，需要进一步的操作以完成请求

400——请求无效，产生原因：前端提交数据的字段名称或者类型与后端未保持一致。或者提交的不是json。

401——请求要求用户的身份认证

403——禁止，服务器理解客户端请求，但是拒绝处理此请求，通常是权限设置所致

404——Not Found，请求的资源不存在

500——内部服务器错误

502——充当网关或代理的服务器从远端服务器接收到一个无效的请求

504——充当网关或代理的服务器，未及时从远端服务器获取请求

#### TCP和UDP的区别

- TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立连接
- TCP提供可靠的服务，也就是说，通过TCP连接传送的数据无差错不丢失，不重复，且按顺序到达；UDP尽最大努力交付，即不保证可靠交付。由于TCP更加可靠，面向连接，不会丢失数据，因此适合大数据量的交换。
- TCP是面向字节流，UDP是面向报文的，并且网络出现拥塞不会使得发送速率降低，因此会出现丢包。
- TCP只能一对一，UDP支持一对一，也支持一对多。
- TCP的首部较大为20字节，而UDP只有8字节。
- TCP是面向连接的可靠性传输，而UDP是不可靠的

#### WebSocket的实现和应用

##### 什么是WebSocket？

WebSocket是H5中的协议，支持持久连接，http协议不支持持久性连接。Http1.0和Http1.1都不支持持久性连接，Http1.1中的keep-alive将多个http请求合并为1个。

##### WebSocket是什么样的协议，具有什么优点？

Http的生命周期通过request来界定，也就是request一个response，那么在http1.0协议中，这次http请求就结束了，在1.1中进行了改进，有一个connection:Keep-alive，也就是说在一个http连接中，可以发送多个request，接收多个response。但是必须记住，在http中的一个request只能对应一个response，而且这个response是被动的，不能主动发起。

WebSocket是基于http协议的，或者说借用了http协议来完成一部分握手，在握手阶段与http是相同的。

#### 管线化

在使用持久连接的情况下，某个连接上的传递类似于

请求1->响应1->请求2->响应2->请求3->响应3

某个连接上的消息变成了类似这样

请求1->请求2->请求3->响应1->响应2->响应3

#### HTTP请求的方式，HEAD方式

head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头。

options：允许客户端查看服务器的性能，比如服务器支持的请求方式等。

#### 一个url访问后直接下载怎样实现？

请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。

#### fetch发送两次请求的原因

fetch发送post请求的时候，总是发送两次，第一次状态码是204，第二次才成功？

因为用fetch的post请求的时候，导致fetch第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二个中发送真正的请求。

#### Cookie、sessionStorage、localStorage的区别

共同点：都是保存在浏览器端，并且是同源的

Cookie：cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径的概念，可以限制cookie只属于某个路径下，存储的大小很小只有4k左右。

sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保存；

localStorage：始终有效，窗口或浏览器关闭页一直保存，因此用作持久数据；cookie旨在设置的cookie过期时间之前一直有效，即使窗口或者浏览器关闭。localStorage在所有同源窗口中都是共享的，并且不会失效，不管窗口或者浏览器关闭与否都会都会始终生效。

cookie的作用：例如将用户的id存储与一个cookie中，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。cookie还可以设置过期时间，当超过过期时间后，cookie就会自动消失。

#### Cookie与Session的区别

cookie数据存放在客户的浏览器上，session数据存储在服务器上；

cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。

session会在一定时间内保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能，应当使用cookie；

单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie。

#### web worker

在HTML页面中，如果在执行脚本时，页面的状态时不可响应的，知道脚本执行完成后，页面才变成可响应。web worker时运行在后台的js，独立于其他的脚本，不会影响页面的性能。并且通过postMessage将结果回传到主线程。这样进行复杂操作的时候，就不会阻塞主线程了。

创建web worker的过程：

检测浏览器对于web worker的支持性；

创建web worker文件

创建web worker对象

#### 在地址栏中输入了一个url，到这个页面呈现出来，中间发生了什么？

输入url后，首先需要找到这个url域名的服务器ip，为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存查找记录为：浏览器缓存>系统缓存>路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器会根据这个ip以及响应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装一个tcp包中，这个tcp包会一次穿过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来做出响应，返回响应的html给浏览器，因为html是一个树形结构，浏览器会根据这个html来构建dom树，在dom树的构建过程中如果遇到js脚本个外部js链接，则会停止构建DOM来执行和下载响应的代码，这会造成阻塞，这就是为了推荐js代码应该放在html之后，之后根据外部样式、内联样式构建一个css对象的模型是cssom树，构建完成后和dom树合并为渲染树，这里做的主要是排除非视觉节点。之后进行布局，布局只要是确定每个节点的尺寸以及位置，之后就是渲染页面。

简单的说就是：

- DNS解析
- TCP链接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析并渲染页面
- 链接结束

#### 常见的HTTP的头部

可以将http首部分为通用首部，请求首部，响应首部，实体首部

通用首部表示一些通用信息，比如date表示报文创建时间

请求首部就是请求报文中独有的，如cookie和缓存相关的如 if-Modified-Since

响应首部就是响应报文中独有的，如set-cookie和重定向相关的location

实体首部用来描述实体部分，如allow用来描述可执行的请求方法，content-type描述主体类型，content-Encoding描述主体的编码方式

#### 描述XSS和CRSF攻击？防御方法？

XSS，即为（Cross Site Scripting)，中文名为跨站脚本，是发生在目标用户的浏览器层面上的，当渲染DOM树的过程中发生了不在预期内执行的js脚本时，就发生了XSS攻击，大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的js代码，实际上是在目标网站的作用域下执行这段js代码。

CSRF(Cross Site Request Forgery)，跨站请求伪造，就是在别的站点伪造了一个请求，就是在受害者访问一个网站时，其Cookie还没有过期的情况下，攻击者伪造一个链接地址发送给受害者并欺骗其点击，从而形成CSRF攻击。

XSS防御的思路：对输入进行过滤，对输出进行编码，也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容，然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。

防御CSRF：验证http referer字段；在请求地址中添加token验证；在HTTP头中字定义属性并验证。